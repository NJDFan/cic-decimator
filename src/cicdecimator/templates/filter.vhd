------------------------------------------------------------------------
-- CIC Decimator {{ name }}
--
-- Stages: {{ stages }}
-- Decimation Ratio: {{ ratio }}
-- Input Data Range: {{ input_min }}-{{ input_max }}
-- Output Data Range: {{ output_min }}-{{ output_max }}
--
-- Generated {{ now }}
-- Generated by Rob Gaddi's {{ program }}.
--
-- This file is a generated output product, and is unencumbered by
-- any license restrictions that may appear in the {{ program }}
-- license; see LICENSE.TXT for more details.
------------------------------------------------------------------------

-- This file is expected to appear in library {{ work }} 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity {{ name }} is
    port (
        in_data     : in  {{ input_dtype }};
        in_valid    : in  std_logic;
        out_data    : out {{ output_dtype }};
        out_valid   : out std_logic;
    
        clk : in std_logic;
        {{ "arst" if async_reset else "rst" }} : in std_logic
    );
end entity {{ name }};

architecture Behavioral of {{ name }} is

    subtype dtype is {{ output_dtype }};
    type dtype_array is array(natural range <>) of dtype;
    subtype ta_dtype  is dtype_array({{stages}} downto 1);
    subtype tex_dtype is dtype_array({{stages}} downto 0);
    
    constant DATA_RESET : ta_dtype := (others => (others => '0'));
    signal integrator : ta_dtype := DATA_RESET;
    signal comb       : ta_dtype := DATA_RESET;
    signal comb_x     : ta_dtype := DATA_RESET;
    
    signal int_flag   : std_logic_vector({{stages}} downto 1) := (others => '0');
    signal comb_flag  : std_logic_vector({{stages}} downto 1) := (others => '0');

begin

    -- For any CIC filter the integrators run on the fast
    -- side, and the combs run on the slow side.  This being
    -- a decimating filter, that puts the integrators on the
    -- input and the combs on the output.

    INTEGRATORS: process(clk {{", arst" if async_reset}})
        variable d     : dtype;
        variable data  : tex_dtype;
        variable flag  : std_logic_vector({{stages}} downto 0);
    begin
        {% if async_reset %}
        -- Asynchronous reset
        if (arst = '1') then
            int_flag   <= (others => '0');
            integrator <= DATA_RESET;
            
        elsif rising_edge(clk) then
        {% else %}
        if rising_edge(clk) then
        {% endif %}
            -- Update the integrator data
            d := RESIZE(in_data, out_data'length);
            data(integrator'range) := integrator;
            data(0) := d;
            flag := int_flag & in_valid;
            
            for i in integrator'range loop
                if flag(i-1) = '1' then
                    integrator(i) <= data(i) + data(i-1);
                end if;
            end loop;
            
            -- Shift the data valid shift register
            int_flag <= flag({{stages-1}} downto 0);
            
            {% if not async_reset %}
            -- Synchronous reset
            if rst = '1' then
                int_flag   <= (others => '0');
                integrator <= DATA_RESET;
            end if;
            {% endif %}
        end if;
    end process INTEGRATORS;
    
    
    COMBS: process(clk {{", arst" if async_reset}})
        variable data  : tex_dtype;
        variable flag  : std_logic_vector({{stages}} downto 0);
    begin
        {% if async_reset %}
        -- Asynchronous reset
        if (arst = '1') then
            comb_flag <= (others => '0');
            comb <= DATA_RESET;
            comb_x <= DATA_RESET;
            
        elsif rising_edge(clk) then
        {% else %}
        if rising_edge(clk) then
        {% endif %}
            -- Update the comb data
            data := comb & integrator(integrator'high);
            flag := comb_flag & int_flag(int_flag'high);
            
            for i in comb'range loop
                if flag(i-1) = '1' then
                    comb(i) <= data(i-1) - comb_x(i);
                    comb_x(i) <= data(i-1);
                end if;
            end loop;
            
            -- Shift the data valid shift register
            comb_flag <= flag({{stages-1}} downto 0);
            
            {% if not async_reset %}
            -- Synchronous reset
            if rst = '1' then
                comb_flag <= (others => '0');
                comb <= DATA_RESET;
                comb_x <= DATA_RESET;
            end if;
            {% endif %}
        end if;
    end process COMBS;
    
    out_data  <= comb(comb'high);
    out_valid <= comb_flag(comb_flag'high);

end architecture Behavioral;
