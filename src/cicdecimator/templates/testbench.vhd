------------------------------------------------------------------------
-- CIC Decimator {{ name }} Testbench tb{{ name }}
--
-- Stages: {{ stages }}
-- Decimation Ratio: {{ ratio }}
-- Input Data Range: {{ input_min }}-{{ input_max }}
-- Output Data Range: {{ output_min }}-{{ output_max }}
--
-- Generated {{ now }}
-- Generated by Rob Gaddi's {{ program }}.
--
-- This file is a generated output product, and is unencumbered by
-- any license restrictions that may appear in the {{ program }}
-- license; see LICENSE.TXT for more details.
------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

{% if osvvm %}
library osvvm;
context osvvm.OsvvmContext;
{% endif %}

{% if (work != "work") %}
library {{ work }};
{% endif %}

entity tb_{{ name }} is
end entity tb_{{ name }};

architecture Testbench of tb_{{ name }} is

    signal in_data     : {{ input_dtype }};
    signal in_valid    : std_logic;
    signal out_data    : {{ output_dtype }};
    signal out_valid   : std_logic;
    signal clk, {{ "arst" if async_reset else "rst" }} : std_logic;

    signal clock_running : boolean;
    signal tClk : time := 10 ns;

    -- In case any of the data is longer than 32 signed bits (i.e. a VHDL
    -- integer) these constants have to be defined in their native types.
    constant INPUT_MIN : {{ input_dtype }} := "{{input_min | binstring(input_bits)}}";    -- {{ input_min }}
    constant INPUT_MAX : {{ input_dtype }} := "{{input_max | binstring(input_bits)}}";    -- {{ input_max }}
    constant OUTPUT_MIN : {{ output_dtype }} := "{{output_min | binstring(output_bits)}}";    -- {{ output_min }}
    constant OUTPUT_MAX : {{ output_dtype }} := "{{output_max | binstring(output_bits)}}";    -- {{ output_max }}

begin

    DUT: entity {{ work }}.{{ name }}
        port map (
            in_data     => in_data,
            in_valid    => in_valid,
            out_data    => out_data,
            out_valid   => out_valid,
            clk         => clk,
            {{ "arst" if async_reset else "rst " }}        => {{ "arst" if async_reset else "rst" }}
        );
    
    CLOCK: process
    begin
        if not clock_running then
            clk <= '0';
            wait until clock_running;
        end if;
        clk <= '0', '1' after tClk / 2;
        wait for tClk;
    end process CLOCK;
    
    {%if osvvm %}
    {% macro assertions(value) %}
        AffirmIf(?? out_valid, "out_valid");
        AffirmIfEqual(out_data, {{ value }}, "out_data");
    {% endmacro %}
    {% else %}
    {% macro assertions(value) %}
        assert out_valid = '1' report "out_valid";
        assert out_data = {{ value }} report "out_data @ {{ value }}";
    {%- endmacro %}
    {% endif %}
    
    BENCH: process
    begin
        {% if osvvm %}
        TranscriptOpen("./results/tb_{{ name }}.txt");
        {% endif %}
        clock_running <= true;
        in_data <= INPUT_MIN;
        in_valid <= '0';
        rst <= '1', '0' after tClk * 5;
        wait for tClk * 5;
        
        -- Feed in exactly enough samples to rail to output min, then give
        -- enough time for the result to propagate.
        in_valid <= '1';
        wait for tClk * {{stages * ratio}};
        in_valid <= '0';
        wait for tClk * {{stages * 2 - 1}};
{{ assertions('OUTPUT_MIN') }}
        
        -- Slam the input to the maximum instead and repeat.
        in_data <= INPUT_MAX;
        in_valid <= '1';
        wait for tClk * {{stages * ratio}};
        in_valid <= '0';
        wait for tClk * {{stages * 2 - 1}};
{{ assertions('OUTPUT_MAX') }}
        
        -- Slam the input back to the minimum again for one more check.
        in_data <= INPUT_MIN;
        in_valid <= '1';
        wait for tClk * {{stages * ratio}};
        in_valid <= '0';
        wait for tClk * {{stages * 2 - 1}};
{{ assertions('OUTPUT_MIN') }}
    
        clock_running <= false;
        {% if osvvm %}
        ReportAlerts;
        {% endif %}
        wait;
    end process BENCH;
    
end architecture Testbench;
